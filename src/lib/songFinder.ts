export interface BaseTrack {
  title: string;
  artist: string;
  artists: string[];
  isrc?: string;
  durationSec?: number;
  album?: string;
  releaseDate?: string;
  label?: string;
  coverArtUrl?: string;
}

interface DeepLinkResponse {
  artist: string;
  title: string;

  spotifyUrl?: string;
  appleMusicUrl?: string;
  youtubeUrl?: string;
  tidalUrl?: string;
  soundcloudUrl?: string;

  spotifyCoverArtUrl?: string;

  appleMusicCoverArtUrl?: string;
  youtubeCoverArtUrl?: string;
  tidalCoverArtUrl?: string;
  soundcloudCoverArtUrl?: string;

  appleMusicConfidence?: number;
  youtubeConfidence?: number;
  tidalConfidence?: number;
  soundcloudConfidence?: number;
}

export async function identifyTrackFromSpotify(
  spotifyUrl: string
): Promise<BaseTrack | null> {
  const res = await fetch("/.netlify/functions/identify-track", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ spotifyUrl }),
  });

  if (!res.ok) {
    console.error("identifyTrackFromSpotify error", await res.text());
    return null;
  }

  const data = await res.json();
  if (!data.ok || !data.track) {
    console.warn("identifyTrackFromSpotify failed", data.reason);
    return null;
  }

  return data.track as BaseTrack;
}

interface AutoGenerateDeepLinksResult {
  success: boolean;
  error?: string;
  track?: {
    title: string;
    artist: string;
    coverArtUrl?: string;
  };
  platforms?: {
    spotify?: string;
    appleMusic?: string;
    youtubeMusic?: string;
    tidal?: string;
    soundcloud?: string;
  };
}

export async function autoGenerateDeepLinks(input: {
  sourceUrl?: string;
  artistSong?: string;
}): Promise<AutoGenerateDeepLinksResult> {
  try {
    // Parse artist and title from artistSong if provided
    let artist = "";
    let title = "";

    if (input.artistSong) {
      const parts = input.artistSong.split(/\s*[-–—]\s*/);
      if (parts.length >= 2) {
        artist = parts[0].trim();
        title = parts.slice(1).join(" - ").trim();
      } else {
        title = input.artistSong.trim();
      }
    }

    const res = await fetch("/.netlify/functions/smart-links", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        spotifyUrl: input.sourceUrl,
        artist,
        title
      }),
    });

    if (!res.ok) {
      const errorText = await res.text().catch(() => "");
      console.error("autoGenerateDeepLinks error", res.status, errorText);

      let errorMessage = "Could not resolve platforms";
      try {
        const errorData = JSON.parse(errorText);
        errorMessage = errorData.message || errorData.error || errorMessage;
      } catch {
        // Keep default error message
      }

      return {
        success: false,
        error: errorMessage
      };
    }

    const response = (await res.json()) as any;

    // Check if response indicates low confidence
    if (response.ok === false && response.reason === "LOW_CONFIDENCE") {
      return {
        success: false,
        error: response.message || "I couldn't confidently match that song. Please paste a Spotify, Apple Music, or YouTube link instead."
      };
    }

    // If no artist and title returned, it failed
    if (!response.artist && !response.title) {
      return {
        success: false,
        error: "Could not identify the track"
      };
    }

    return {
      success: true,
      track: {
        title: `${response.artist} - ${response.title}`.trim(),
        artist: response.artist,
        coverArtUrl: response.spotifyCoverArtUrl || response.appleMusicCoverArtUrl || response.youtubeCoverArtUrl
      },
      platforms: {
        spotify: response.spotifyUrl,
        appleMusic: response.appleMusicUrl,
        youtubeMusic: response.youtubeUrl,
        tidal: response.tidalUrl,
        soundcloud: response.soundcloudUrl
      }
    };
  } catch (err: any) {
    console.error("autoGenerateDeepLinks exception", err);
    return {
      success: false,
      error: err.message || "Network error"
    };
  }
}
